
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

#
# Copyright 2019 Joyent, Inc.
#

#
# Makefile.targ: common targets.
#

#
# NOTE: This makefile comes from the "eng" repo. If you find yourself changing
# this file, you should ensure that you test all consumers of it, since
# eng.git is a git submodule of several repositories. After testing, push
# changes to the eng.git gerrit project as normal, then do the following for
# each component that uses eng.git, likely reusing the original ticket subject
# for the commit message as was used for the eng.git push.
#
#    $ git submodule update --remote deps/eng
#    $ git add deps/eng
#    $ git commit -m "TOOLS-xxxx some description" deps/eng
#
# Then push those changes to gerrit as usual for review.
#

#
# This Makefile defines several useful targets and rules. You can use it by
# including it from a Makefile that specifies some of the variables below.
#
# Targets defined in this Makefile:
#
#	bits-upload	Upload the bits produced by the component Makefile's
#			'publish' target to Manta or a local filesystem,
#			optionally publishing images to updates.joyent.com
#
#	bits-upload-latest
#			As above, but use the bits/<component>/latest-build-stamp
#			file to determine the $(STAMP) of the uploaded bits
#
#	buildimage	Builds an image
#
#	check		- check-jsl: Check JavaScript lint with 'jsl'
#			  See JSL_ vars below.
#			- check-jsstyle: Check JavaScript style with 'jsstyle'.
#			  See JSSTYLE_ vars below.
#			- check-bash: Checks $BASH_FILES for style.
#			- check-manifests: Checks SMF manifests for validity
#			  against the SMF DTD. See "Makefile.smf.defs".
#			- check-rust: Checks rust files using `cargo clippy`
#			  See "RUST_*" vars below.
#			- check-copyright: Checks "Copyright" statements in
#			  files different from master. See
#			  "ENGBLD_CHECK_COPYRIGHT_" vars below.
#
#	clean		Removes built files
#
#	docs		Builds restdown documentation in docs/
#
#	prepublish	Is depended upon by "publish", saves the $(STAMP)
#			of our last published bits, used by bits-upload.sh,
#			as well as data about the build environment
#
#	prepush		Depends on "check" and "test"
#
#	show-buildenv	Emits the pkgsrc version required for this component,
#			if available
#
#	test		Does nothing (you should override this)
#
#	validate-buildenv
#			Runs a series of checks to determine if the build
#			environment is valid for this component
#
#	xref		Generates cscope (source cross-reference index)
#
# For details on what these targets are supposed to do, see the Joyent
# Engineering Guide.
#
# To make use of these targets, you'll need to set some of these variables. Any
# variables left unset will simply not be used.
#
#	BASH_FILES	Bash scripts to check for syntax
#			(paths relative to top-level Makefile)
#
#	CLEAN_FILES	Files to remove as part of the "clean" target.  Note
#			that files generated by targets in this Makefile are
#			automatically included in CLEAN_FILES.  These include
#			restdown-generated HTML and JSON files.
#
#	DOC_FILES	Restdown (documentation source) files. These are
#			assumed to be contained in "docs/", and must NOT
#			contain the "docs/" prefix.
#
#	JSL_CONF_NODE	Specify JavaScriptLint configuration files
#	JSL_CONF_WEB	(paths relative to top-level Makefile)
#
#			Node.js and Web configuration files are separate
#			because you'll usually want different global variable
#			configurations.  If no file is specified, none is given
#			to jsl, which causes it to use a default configuration,
#			which probably isn't what you want.
#
#	JSL_FILES_NODE	JavaScript files to check with Node config file.
#	JSL_FILES_WEB	JavaScript files to check with Web config file.
#
#	JSON_FILES	JSON files to be validated
#
#	JSSTYLE_FILES	JavaScript files to be style-checked
#
#	RUST_CODE	Set this, `RUST_CODE=1` to enable cargo clippy as part
#			of `make check`.
#	RUST_CLIPPY_ARGS
#			Alternative options to pass to `cargo clippy` as part
#			of `make check`. By default it is
#			"-- -D clippy::all -D clippy::pedantic". Other options:
#			- full clippy:
#			  RUST_CLIPPY_ARGS="-- -D clippy::all -D clippy::pedantic -D clippy::nursery -D clippy::cargo"
#			- just warn:
#			  RUST_CLIPPY_ARGS="-- -W clippy::all"
#			Specific clippy checks can be ignored via Rust
#			attributes at the module or function level, e.g.
#			    #[allow(clippy::match_bool)]
#			    fn post_timer_metrics(method: Method, ...) {
#
#	ENGBLD_CHECK_COPYRIGHT_DISABLE
#			Set this to disable "check-copyright".
#	ENGBLD_CHECK_COPYRIGHT_ARGS
#			Arguments to pass invocations of "check-copyright".
# 			Run the following to see available options:
#			    make check-copyright ENGBLD_CHECK_COPYRIGHT_ARGS=-h
#
# You can also override these variables:
#
#	BASH		Path to bash (default: "bash")
#
#	BUILD		top-level directory for node binaries, generated docs,
#			and any other build output (default: "build")
#
#	CARGO		Path to cargo (default: "cargo")
#
#	CSCOPE_DIRS	Directories to search for source files for the cscope
#			index. (default: ".")
#
#	ENGBLD_BITS_UPLOAD_OVERRIDE
#			Set this to allow a component Makefile to declare its
#			own 'bits-upload' and 'bits-upload-latest' targets
#
#	ESLINT		Path to eslint (default: "eslint")
#
#	ESLINT_FLAGS	Additional flags to pass through to eslint
#
#	JSL		Path to JavaScriptLint (default: "jsl")
#
#	JSL_FLAGS_NODE	Additional flags to pass through to JSL
#	JSL_FLAGS_WEB
#	JSL_FLAGS
#
#	JSON		Path to json tool (default: "json")
#
#	JSSTYLE		Path to jsstyle (default: "jsstyle")
#
#	JSSTYLE_FLAGS	Additional flags to pass through to jsstyle
#
#	RESTDOWN_EXT	By default '.md' is required for DOC_FILES (see above).
#			If you want to use, say, '.restdown' instead, then set
#			'RESTDOWN_EXT=.restdown' in your Makefile.
#

#
# Defaults for the various tools we use.
#
BASH		?= bash
BASHSTYLE   	?= $(NODE) deps/eng/tools/bashstyle
CARGO		?= cargo
ENGBLD_CHECK_COPYRIGHT ?= deps/eng/tools/check-copyright
ENGBLD_CHECK_COPYRIGHT_ARGS ?= -q
CP		?= cp
CSCOPE		?= cscope
CSCOPE_DIRS	?= .
ESLINT		?= eslint
JSL		?= jsl
JSON		?= json
JSSTYLE		?= jsstyle
MKDIR		?= mkdir -p
MV		?= mv
RESTDOWN_FLAGS	?=
RESTDOWN_EXT	?= .md
RMTREE		?= rm -rf
RUST_CLIPPY_ARGS ?= -- -D clippy::all -D clippy::pedantic
JSL_FLAGS  	?= --nologo --nosummary

ifeq ($(shell uname -s),SunOS)
	TAR	?= gtar
else
	TAR	?= tar
endif


#
# Defaults for other fixed values.
#
BUILD		?= build
DISTCLEAN_FILES += $(BUILD) bits
DOC_BUILD	= $(BUILD)/docs/public

#
# Configure JSL_FLAGS_{NODE,WEB} based on JSL_CONF_{NODE,WEB}.
#
ifneq ($(origin JSL_CONF_NODE), undefined)
	JSL_FLAGS_NODE += --conf=$(JSL_CONF_NODE)
endif

ifneq ($(origin JSL_CONF_WEB), undefined)
	JSL_FLAGS_WEB += --conf=$(JSL_CONF_WEB)
endif

#
# Targets. For descriptions on what these are supposed to do, see the
# Joyent Engineering Guide.
#

#
# Instruct make to keep around temporary files. We have rules below that
# automatically update git submodules as needed, but they employ a deps/*/.git
# temporary file. Without this directive, make tries to remove these .git
# directories after the build has completed.
#
.SECONDARY: $($(wildcard deps/*):%=%/.git)

#
# This rule enables other rules that use files from a git submodule to have
# those files depend on deps/module/.git and have "make" automatically check
# out the submodule as needed.
#
deps/%/.git:
	git submodule update --init deps/$*

#
# These recipes make heavy use of dynamically-created phony targets. The parent
# Makefile defines a list of input files like BASH_FILES. We then say that each
# of these files depends on a fake target called filename.bashchk, and then we
# define a pattern rule for those targets that runs bash in check-syntax-only
# mode. This mechanism has the nice properties that if you specify zero files,
# the rule becomes a noop (unlike a single rule to check all bash files, which
# would invoke bash with zero files), and you can check individual files from
# the command line with "make filename.bashchk".
#
# Since bashstyle is a node program, we need our node runtime as a dependency
# for running $(BASHSTYLE)
#
.PHONY: check-bash
check-bash: $(NODE_EXEC) $(BASH_FILES:%=%.bashchk) $(BASH_FILES:%=%.bashstyle)

%.bashchk: %
	$(BASH) -n $^

%.bashstyle: %
	$(BASHSTYLE) $^

.PHONY: check-json
check-json: $(JSON_FILES:%=%.jsonchk)

%.jsonchk: %
	$(JSON) --validate -f $^

#
# The above approach can be slow when there are many files to check because it
# requires that "make" invoke the check tool once for each file, rather than
# passing in several files at once.  For the JavaScript check targets, we define
# a variable for the target itself *only if* the list of input files is
# non-empty.  This avoids invoking the tool if there are no files to check.
#

ESLINT_TARGET = $(if $(ESLINT_FILES), check-eslint)
.PHONY: check-eslint
check-eslint: $(ESLINT_EXEC)
	$(ESLINT) $(ESLINT_FLAGS) $(ESLINT_FILES)

JSL_NODE_TARGET = $(if $(JSL_FILES_NODE), check-jsl-node)
.PHONY: check-jsl-node
check-jsl-node: $(JSL_EXEC)
	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_NODE) $(JSL_FILES_NODE)

JSL_WEB_TARGET = $(if $(JSL_FILES_WEB), check-jsl-web)
.PHONY: check-jsl-web
check-jsl-web: $(JSL_EXEC)
	$(JSL) $(JSL_FLAGS) $(JSL_FLAGS_WEB) $(JSL_FILES_WEB)

.PHONY: check-jsl
check-jsl: $(JSL_NODE_TARGET) $(JSL_WEB_TARGET)

JSSTYLE_TARGET = $(if $(JSSTYLE_FILES), check-jsstyle)
.PHONY: check-jsstyle
check-jsstyle:  $(JSSTYLE_EXEC)
	$(JSSTYLE) $(JSSTYLE_FLAGS) $(JSSTYLE_FILES)

# We run `cargo clean` before `cargo clippy` because, at least in Rust v1.35
# clippy will not check already compiled files.
# https://github.com/rust-lang/cargo/pull/7157 might fix this.
RUST_CHECK_TARGET = $(if $(RUST_CODE), check-rust)
.PHONY: check-rust
check-rust:
	$(CARGO) clean && $(CARGO) clippy $(RUST_CLIPPY_ARGS)

_CHECK_COPYRIGHT_TARGET = $(if $(ENGBLD_CHECK_COPYRIGHT_DISABLE),,check-copyright)
.PHONY: check-copyright
check-copyright:
	$(ENGBLD_CHECK_COPYRIGHT) $(ENGBLD_CHECK_COPYRIGHT_ARGS)

.PHONY: check
check:: $(ESLINT_TARGET) check-jsl check-json $(JSSTYLE_TARGET) check-bash $(RUST_CHECK_TARGET) $(_CHECK_COPYRIGHT_TARGET)
	@echo check ok

.PHONY: clean
clean::
	-$(RMTREE) $(CLEAN_FILES)

.PHONY: distclean
distclean:: clean
	-$(RMTREE) $(DISTCLEAN_FILES)

CSCOPE_FILES = cscope.in.out cscope.out cscope.po.out
CLEAN_FILES += $(CSCOPE_FILES)

.PHONY: xref
xref: cscope.files
	$(CSCOPE) -bqR

.PHONY: cscope.files
cscope.files:
	find $(CSCOPE_DIRS) -name '*.c' -o -name '*.h' -o -name '*.cc' \
	    -o -name '*.js' -o -name '*.s' -o -name '*.cpp' > $@

#
# The "docs" target is complicated because we do several things here:
#
#    (1) Use restdown to build HTML and JSON files from each of DOC_FILES.
#
#    (2) Copy these files into $(DOC_BUILD) (build/docs/public), which
#        functions as a complete copy of the documentation that could be
#        mirrored or served over HTTP.
#
#    (3) Then copy any directories and media from docs/media into
#        $(DOC_BUILD)/media. This allows projects to include their own media,
#        including files that will override same-named files provided by
#        restdown.
#
# Step (3) is the surprisingly complex part: in order to do this, we need to
# identify the subdirectories in docs/media, recreate them in
# $(DOC_BUILD)/media, then do the same with the files.
#
DOC_MEDIA_DIRS := $(shell find docs/media -type d 2>/dev/null | grep -v "^docs/media$$")
DOC_MEDIA_DIRS := $(DOC_MEDIA_DIRS:docs/media/%=%)
DOC_MEDIA_DIRS_BUILD := $(DOC_MEDIA_DIRS:%=$(DOC_BUILD)/media/%)

DOC_MEDIA_FILES := $(shell find docs/media -type f 2>/dev/null)
DOC_MEDIA_FILES := $(DOC_MEDIA_FILES:docs/media/%=%)
DOC_MEDIA_FILES_BUILD := $(DOC_MEDIA_FILES:%=$(DOC_BUILD)/media/%)

#
# Like the other targets, "docs" just depends on the final files we want to
# create in $(DOC_BUILD), leveraging other targets and recipes to define how
# to get there.
#
.PHONY: docs
docs::							\
	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.html)		\
	$(DOC_FILES:%$(RESTDOWN_EXT)=$(DOC_BUILD)/%.json)		\
	$(DOC_MEDIA_FILES_BUILD)

#
# We keep the intermediate files so that the next build can see whether the
# files in DOC_BUILD are up to date.
#
.PRECIOUS:					\
	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%json)

#
# We do clean those intermediate files, as well as all of DOC_BUILD.
#
CLEAN_FILES +=					\
	$(DOC_BUILD)				\
	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.html)		\
	$(DOC_FILES:%$(RESTDOWN_EXT)=docs/%.json)

#
# Before installing the files, we must make sure the directories exist. The |
# syntax tells make that the dependency need only exist, not be up to date.
# Otherwise, it might try to rebuild spuriously because the directory itself
# appears out of date.
#
$(DOC_MEDIA_FILES_BUILD): | $(DOC_MEDIA_DIRS_BUILD)

$(DOC_BUILD)/%: docs/% | $(DOC_BUILD)
	$(MKDIR) $(shell dirname $@)
	$(CP) $< $@

docs/%.json docs/%.html: docs/%$(RESTDOWN_EXT) | $(DOC_BUILD) $(RESTDOWN_EXEC) \
    $(EXTRA_DOC_DEPS)
	$(RESTDOWN) $(RESTDOWN_FLAGS) -m $(DOC_BUILD) $<

$(DOC_BUILD):
	$(MKDIR) $@

$(DOC_MEDIA_DIRS_BUILD):
	$(MKDIR) $@

#
# The default "test" target does nothing. This should usually be overridden by
# the parent Makefile. It's included here so we can define "prepush" without
# requiring the repo to define "test".
#
.PHONY: test
test:

.PHONY: prepush
prepush: check test

#
# Ensure we have a sane build environment. The script includes an escape
# hatch in case of emergencies. set ENGBLD_SKIP_VALIDATE_BUILDENV=true in the
# environment to have it always pass.
#
.PHONY: validate-buildenv
validate-buildenv:
	$(TOP)/deps/eng/tools/validate-buildenv.sh

.PHONY: show-buildenv
show-buildenv:
	@$(TOP)/deps/eng/tools/validate-buildenv.sh -r

#
# Everything should depend on us having a valid build environment.
#
all release publish buildimage: validate-buildenv

publish: prepublish

#
# Store some information about the build environment. The latest-build-stamp
# file is used if running the 'bits-upload-latest' target. See bits-upload.sh.
# When generating npm-ls.json output, we ignore errors since older versions
# of npm seem to sometimes install packages that /opt/tools/bin/npm deems
# "invalid". That shouldn't be allowed to fail the build.
#
.PHONY: prepublish
prepublish:
	-mkdir -p $(ENGBLD_BITS_DIR)/$(NAME)
	echo $(STAMP) > $(ENGBLD_BITS_DIR)/$(NAME)/latest-build-stamp
	@echo "Generating $(ENGBLD_BITS_DIR)/$(NAME)/build-environment"
	@if [[ "$$(uname -s)" == "SunOS" ]]; then \
		MAKE_PID=$$(/usr/bin/ps -o ppid= -p $$$$); \
		BUILD_IMG_UUID=$$($(PFEXEC) /usr/sbin/mdata-get sdc:image_uuid); \
		echo hostname: $$(/usr/bin/hostname) > $(ENGBLD_BITS_DIR)/$(NAME)/build-environment; \
		/usr/bin/cat /etc/pkgsrc_version >> $(ENGBLD_BITS_DIR)/$(NAME)/build-environment; \
		echo image_uuid: $$BUILD_IMG_UUID >> $(ENGBLD_BITS_DIR)/$(NAME)/build-environment; \
	fi
	@echo "Generating $(ENGBLD_BITS_DIR)/$(NAME)/npm-ls.json"
	-/opt/tools/bin/npm ls --json > $(ENGBLD_BITS_DIR)/$(NAME)/npm-ls.json


#
# Transform the boolean into the appropriate cli flag
#
ifdef BUILDIMAGE_DO_PKGSRC_UPGRADE
BUILDIMAGE_DO_PKGSRC_UPGRADE_ARGS=-u
endif


#
# The list of pkgsrc packages that should be installed in the
# image that the 'buildimage' target constructs. Set here rather than
# in Makefile.defs to ensure it's always computed after $(BUILDIMAGE_PKGSRC)
# is set.
#
ifdef BUILDIMAGE_PKGSRC
BUILDIMAGE_PKGSRC_ARGS = -p $$(echo $(BUILDIMAGE_PKGSRC) | sed -e 's/ /,/g')
else
BUILDIMAGE_PKGSRC_ARGS =
endif

#
# If buildimage should not create an etc/motd file for the image, set
# BUILDIMAGE_SKIP_MOTD.
#
ifndef BUILDIMAGE_SKIP_MOTD
BUILDIMAGE_MOTD_ARGS = -M -S "$$(git -C $(TOP) remote get-url origin)"
else
BUILDIMAGE_MOTD_ARGS =
endif

#
# BUILDIMAGE_PKG should nearly always be set to $(TOP)/$(RELEASE_TARBALL),
# but ensure RELEASE_TARBALL is set before setting that default.
#
ifeq ($(ENGBLD_USE_BUILDIMAGE), true)

ifndef BUILDIMAGE_PKG
  ifndef RELEASE_TARBALL
    $(error "Error: RELEASE_TARBALL must be set before including Makefile.targ")
  else
    BUILDIMAGE_PKG=$(TOP)/$(RELEASE_TARBALL)
  endif
endif

endif

#
# We add a guard to ensure that users haven't invoked 'make buildimage'
# by accident. It's better to bail out early with an clear error message
# if a user has not declared that their component should $ENGBLD_USE_BUILDIMAGE.
#
.PHONY: buildimage
buildimage: stamp-buildimage-prep release $(AGENTS:%=%-prebuilt)
	if [[ "$(ENGBLD_USE_BUILDIMAGE)" != "true" ]]; then \
		echo "This component is not configured to use buildimage."; \
		echo "Set 'ENGBLD_USE_BUILDIMAGE=true' in the component Makefile otherwise."; \
		exit 1; \
	fi
	mkdir -p $(ENGBLD_BITS_DIR)/$(NAME)
	mkdir -p $(BUILDIMAGE_STAGEDIR)
	cd $(BUILDIMAGE_STAGEDIR) ; \
	$(TOP)/deps/eng/tools/buildimage-extract-pkg.sh $(BUILDIMAGE_PKG)
	$(PFEXEC) chown -R root:root $(BUILDIMAGE_STAGEDIR)
	cd $(BUILDIMAGE_STAGEDIR); \
	$(PFEXEC) $(BUILDIMAGE) \
		-i $(BASE_IMAGE_UUID) \
		-d $(BUILDIMAGE_STAGEDIR)/root \
		-m '$(BUILDIMAGE_MF)' \
		$(BUILDIMAGE_DO_PKGSRC_UPGRADE_ARGS) \
		$(BUILDIMAGE_PKGSRC_ARGS) \
		$(BUILDIMAGE_MOTD_ARGS) \
		-a \
		-P $(NAME)-zfs
	cp /tmp/$(NAME)-zfs-$(BUILDIMAGE_VERSION).zfs.gz $(ENGBLD_BITS_DIR)/$(NAME)
	cp /tmp/$(NAME)-zfs-$(BUILDIMAGE_VERSION).imgmanifest $(ENGBLD_BITS_DIR)/$(NAME)
	cp /tmp/$(NAME)-zfs-$(BUILDIMAGE_VERSION).pkgaudit $(ENGBLD_BITS_DIR)/$(NAME)
	$(PFEXEC) rm /tmp/$(NAME)-zfs-$(BUILDIMAGE_VERSION).zfs.gz
	$(PFEXEC) rm /tmp/$(NAME)-zfs-$(BUILDIMAGE_VERSION).imgmanifest
	$(PFEXEC) rm /tmp/$(NAME)-zfs-$(BUILDIMAGE_VERSION).pkgaudit
	$(PFEXEC) rm -rf $(BUILDIMAGE_STAGEDIR)

#
# Upload the build products from this component's ./bits directory
# to either manta or a filesystem path. We allow consumers to override
# this, supplying their own custom bits-upload* targets by setting
# ENGBLD_BITS_UPLOAD_OVERRIDE.
#
ifndef ENGBLD_BITS_UPLOAD_OVERRIDE
.PHONY: bits-upload
bits-upload: publish $(BUILDIMAGE_TARG)
	$(TOP)/deps/eng/tools/bits-upload.sh \
		-b "$(BRANCH)" \
		-B "$(TRY_BRANCH)" \
		$(BITS_UPLOAD_LOCAL_ARG) \
		$(BITS_UPLOAD_IMGAPI_ARG) \
		-d $(ENGBLD_DEST_OUT_PATH)/$(NAME) \
		-D $(ENGBLD_BITS_DIR) \
		-n $(NAME) \
		-t $(STAMP)

#
# A convenience target that doesn't require us to do a full build. We derive
# the timestamp for the bits being uploaded from the latest-build-stamp file
# in build/bits directory, produced by the 'prepublish' target.
#
.PHONY: bits-upload-latest
bits-upload-latest:
	$(TOP)/deps/eng/tools/bits-upload.sh \
		-b "$(BRANCH)" \
		-B "$(TRY_BRANCH)" \
		$(BITS_UPLOAD_LOCAL_ARG) \
		$(BITS_UPLOAD_IMGAPI_ARG) \
		-d $(ENGBLD_DEST_OUT_PATH)/$(NAME) \
		-D $(ENGBLD_BITS_DIR) \
		-n $(NAME)
endif

#
# Do an npm install for the dependencies of buildimage itself.
#
$(STAMP_BUILDIMAGE_PREP):
	$(MAKE_STAMP_REMOVE); \
	cd $(TOP)/deps/eng/tools/buildimage; \
	$(MAKE) buildimage-prep
	$(MAKE_STAMP_CREATE)

#
# This rule automatically exposes every "stamp" file as a target that can be
# invoked manually as "stamp-$STAMP_NAME".  For example, if a stamp has been
# defined thus:
#
#	STAMP_EXPENSIVE_RESULT := $(MAKE_STAMPS_DIR)/expensive-result
#
# ... this can be invoked manually as "make stamp-expensive-result".  Note that
# these phony targets are essentially just for interactive usage.  Targets
# should be specified to depend on the macro containing the stamp file name.
#
# See also the comments in "Makefile.defs".
#
stamp-%: $(MAKE_STAMPS_DIR)/%
	@:

#
# Allow for easier Makefile debugging. 'make print-FOO' will emit the value
# of $(FOO).
#
print-%:
	@echo '$*=$($*)'
